# 项目小技巧

* 限制号码的长度，可以直接在模型下面`class`直接写这个**钩子方法**

> ```python
> class teacherModelForm(forms.ModelForm):
>     class Meta:
>         # 这个是模型
>         model = models.teachers
>         fields = '__all__'
> ```
>
> ```python
> # 去重以及规定号码格式
> # 重点在于 clean_ 要处理哪个字段后面就是那个字段的名称,后面同理
> def clean_number(self):
>     number = self.cleaned_data['number']
>     exists = models.teachers.objects.filter(number=number).exists()  
>     # 判断数据（电话号码）是否唯一，赋予的结果是一个布尔类型的值
>     if len(number) != 11:
>         raise ValidationError('格式错误')
>     elif exists:
>         raise ValidationError('号码已经存在')
>     return number
> ```

* 在同一个界面想要展示的数据就必须全部返回，只要有界面返回就必须将需要在前端显示的数据进行返回，如下

> ```python
> return render(request, 'teachers_add.html', {'form': form, 'data': data})
> ```

* 对于信息的编辑，我们同样可以采取这样的方法，可以实现编辑前的数据显示在编辑栏内。同时在前端的编辑界面，应该和添加界面应该是一致的

  > ```python
  > if request.method == 'GET':
  >     edit = models.students.objects.filter(id=nid).first()
  >     form = studentModelForm(instance=edit)
  >     return render(request,'student_edit.html', {'form': form,})
  > 	#这里以上代码用于将数据修改前的数据显示在界面上
  > edit = models.students.objects.filter(id=nid).first()
  > form = studentModelForm(data=request.POST,instance=edit)
  > if form.is_valid():
  >     form.save()
  >     return redirect('/index/studentlist/')
  > return render(request, 'student_edit.html', {'form': form})
  > # 以上就是将数据进行校验和保存的常规操作
  > ```
  >
  > - 需要注意这里面的`edit`这个变量以及`instance`这个参数

* 搜索框最好采用这样的形式去写，后端通过`search = request.GET.get('Q')`得到数据

  > ```html
  > <div style="float: right;width: 400px">
  >     <form method="get">
  >         <div class="input-group">
  >             <input type="text" class="form-control" name="Q" placeholder="请输入需要搜索内容">
  >             <span class="input-group-btn">
  >         <button class="btn btn-default" type="submit">
  >             <span class="glyphicon glyphicon-search" aria-hidden="true"></span>
  >         </button>
  >     </span>
  >         </div><!-- /input-group -->
  >     </form>
  > </div>
  > ```
  
  ***
  
* 有时候项目的代码片段不一定会生效，你写了但是就是没有效果，比如钩子方法添加校验条件时，该条件就是不生效，此时你需要将该代码块重写一遍即可解决问题。且此问题多发于该代码块是复制（复用）的前提下。

  ***

* 对于项目的校验，如果采用第一种方式会导致新增和修改都会被校验，修改过程中校验会识别到数据库里面自己已经存在，所以报错进而无法修改，但是修改并不需要唯一性校验。这时候就要用到方法二，类似的业务逻直接拿来用即可，只需修改对应模型即可

  > 方式1
  >
  > ```python
  > def clean_number(self):
  >  number = self.cleaned_data['number']
  >  exists = models.students.objects.filter(number=number).exists()
  >  if len(number) != 8:
  >      raise ValidationError('格式错误')
  >  elif exists:
  >      raise ValidationError('学号已经存在')
  >  return number
  > ```
  >
  > 方式2
  >
  > ```python
  > def clean_需要校验的字段名(self):
  >  number = self.cleaned_data['需要校验的字段名']
  >  if len(number) != 8:
  >      raise ValidationError('格式错误')
  > 
  >  # 检查是否是创建新记录还是更新现有记录
  >  if self.instance and self.instance.pk:  # 这是更新操作
  >      exists = models.students.objects.filter(number=number).exclude(pk=self.instance.pk).exists()
  >  else:  # 这是创建操作
  >      exists = models.students.objects.filter(number=number).exists()
  > 
  >  if exists:
  >      raise ValidationError('学号已经存在')
  > 
  >  return number
  > ```
  >
  > 方式2：更加详细解释
  >
  > ```python
  > def clean_<fieldname>(self):
  >  """检查字段是否唯一（适用于新增和修改）"""
  >  field_value = self.cleaned_data['<fieldname>']
  > 
  >  # 1. 先检查格式（如果有要求）
  >  if len(field_value) != <期望长度>:  # 比如学号必须 8 位
  >      raise ValidationError('格式错误')
  > 
  >  # 2. 检查是否已存在（区分新增和修改）
  >  if self.instance and self.instance.pk:  # 修改操作
  >      exists = <Model>.objects.filter(<fieldname>=field_value).exclude(pk=self.instance.pk).exists()
  >  else:  # 新增操作
  >      exists = <Model>.objects.filter(<fieldname>=field_value).exists()
  > 
  >  if exists:
  >      raise ValidationError('该值已存在，请更换')
  > 
  >  return field_value
  > ```
  >
  > 错误解释：针对`Studentmanager`项目
  >
  > 1: <u>你的问题是在修改信息时，Django的表单校验仍然会检查学号是否已存在，这会导致即使只是修改同一个学生的其他信息（而不改变学号）也会触发校验错误。</u>
  >
  > 2: <u>这是因为你的 `clean_number()` 方法没有考虑编辑现有记录的情况。你需要修改校验逻辑，使其在编辑时忽略当前记录的学号。</u>
***

* 在一个HTML界面中如果存在多个from的数据传输需求，且是不同的视图函数中发送过来的，就请务必将from的名字设置的不同，别一股脑的全部设置成一样的。每个from只负责他需要的部分，比如我需要在一个**学生信息展示界面**进行**学生信息创建的功能**，这里就要求我必须存在两个from，一个是学生信息展示界面的`from`，一个是用于构筑输入框的`modelfrom`，他们都需要传入前端，且放置在不同的位置，且分别来自不同的视图函数，那么就需要用不同的名字，他们是可以共存的，<u>且记住from表单即使写在一张HTML里面，他们也可以设置不同的action传输到不同的视图函数中，避免打架`<form method="post" action="/index/studentadd/" novalidate></form>`</u>
* 详见项目`studentmanager`

***

加载文件的时候要时刻记得在html文件中添加`{% load static %}`，然后引用采用`{% static 'URL' %}`

***

对于需要给`modelform`添加样式的操作，我们知道可以在实现类的时候添加`widgets = {}`的方法,然后在里面给该输入框添加样式，不仅是bootstrap，比如从网上下载的模板，为了替代其输入框又要保持其主题一致时就可以这样搞，

比如原来的模板里面是`<input type="password" class="form-text">`那么我们只需要在后端设置

`widgets = {'username': forms.TextInput(attrs={'class': 'form-text'}),}`即可,保持class的一致

***

写完登录界面和基础验证逻辑以后，记得写中间件，而且要把中间件在settings里面注册一下

***

注意一个小问题，就是钩子方法的验证必须先想好，不然可能会导致无法登陆的问题，比方说，我已经在数据里存了管理员账户和管理员密码，密码为**六位数**，但是在钩子方法里面（本来是用于验证新建管理员时的密码格式）我限制其为八位数，那么此时登录就会导致前端返回错误`ValueError: The view app01.views.login didn't return an HttpResponse object. It returned None instead.`，无法接受到任何返回值，因为钩子方法的验证问题，这个登录信息也会被拦截，从而无法得到session信息以及写入cookie和session信息。



